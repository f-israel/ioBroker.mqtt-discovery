{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.5\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from \"@iobroker/adapter-core\";\nimport { EXIT_CODES } from \"@iobroker/adapter-core\";\nimport * as mqtt from \"mqtt\";\nimport { findStatesMarkedWithEnum } from \"./lib/state-finder\";\nimport { generateDiscoveryMessage, type HomeassistantComponent } from \"./lib/mqtt-discovery-helper\";\nimport { clearInterval } from \"node:timers\";\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\nclass MqttDiscovery extends utils.Adapter {\n    // MQTT-Client speichern \u2013 initial null\n    private client: mqtt.MqttClient | null = null;\n    private useMqttInstance: boolean = false;\n    private isFirstTimeConnect: boolean = true;\n    private rescanInterval: NodeJS.Timeout | null = null;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: \"mqtt-discovery\",\n        });\n        // Registriere Event-Handler\n        this.on(\"ready\", this.onReady.bind(this));\n        this.on(\"unload\", this.onUnload.bind(this));\n    }\n\n    /**\n     * Wird aufgerufen, wenn der Adapter bereit ist.\n     */\n    private async onReady(): Promise<void> {\n        if (!this.config.mqttInstance && !this.config.mqttHost) {\n            this.stop && void this.stop({ reason: \"Not configured\", exitCode: EXIT_CODES.INVALID_ADAPTER_CONFIG });\n        }\n\n        await this.extendObject(\"device_count\", { type: \"state\", common: { write: false, type: \"number\", def: 0 } });\n        await this.extendObject(\"sensor_count\", { type: \"state\", common: { write: false, type: \"number\", def: 0 } });\n        await this.extendObject(\"switch_count\", { type: \"state\", common: { write: false, type: \"number\", def: 0 } });\n\n        // Pr\u00FCfe, ob eine bestehende MQTT-Instanz ausgew\u00E4hlt wurde\n        if (this.config.mqttInstance && this.config.mqttInstance !== \"\") {\n            this.log.info(`Verwende vorhandene MQTT-Instanz: ${this.config.mqttInstance}`);\n            this.useMqttInstance = true;\n            // Bei Verwendung einer Instanz erfolgt das Publish sp\u00E4ter \u00FCber sendTo\n            if (await this.checkDiscoveryWrite()) {\n                this.log.debug(\"MQTT-Publish-Test erfolgreich\");\n                await this.publishDiscovery();\n\n                await this.setStateChangedAsync(\"info.connection\", true, true);\n                if (this.config.stateRescanInterval && !this.rescanInterval) {\n                    this.rescanInterval = setInterval(\n                        this.publishDiscovery.bind(this),\n                        this.config.stateRescanInterval * 1000,\n                    );\n                }\n            } else {\n                this.log.error(\"MQTT-Publish ist nicht erlaubt\");\n            }\n        } else {\n            // Direktverbindung: Erstelle den Verbindungs-URL aus Protokoll, Host und Port\n            const protocol: string = this.config.mqttProtocol || \"mqtt\";\n            const host: string = this.config.mqttHost || \"localhost\";\n            const port: number = this.config.mqttPort || 1883;\n            const username: string = this.config.mqttUsername || \"\";\n            const password: string = this.config.mqttPassword || \"\";\n            const clientId: string = this.config.mqttClientId || \"ioBroker-mqtt-discovery\";\n            const url = `${protocol}://${host}:${port}`;\n\n            this.log.info(`Verbinde direkt zu MQTT-Broker unter ${url} als ${clientId}`);\n            const options: mqtt.IClientOptions = { clientId };\n            if (username) {\n                options.username = username;\n            }\n            if (password) {\n                options.password = password;\n            }\n\n            this.client = mqtt.connect(url, options);\n            this.client.on(\"connect\", async () => {\n                this.isFirstTimeConnect = false;\n                this.log.info(\"Direkte MQTT-Verbindung hergestellt.\");\n                if (await this.checkDiscoveryWrite()) {\n                    this.log.debug(\"MQTT-Publish-Test erfolgreich\");\n                    await this.publishDiscovery();\n                    await this.setStateChangedAsync(\"info.connection\", true, true);\n                    if (this.config.stateRescanInterval && !this.rescanInterval) {\n                        this.rescanInterval = setInterval(\n                            this.publishDiscovery.bind(this),\n                            this.config.stateRescanInterval * 1000,\n                        );\n                    }\n                } else {\n                    this.log.error(\"MQTT-Publish ist nicht erlaubt\");\n                    this.client!.end();\n                }\n            });\n            this.client.on(\"error\", async (err: Error) => {\n                if (err instanceof AggregateError && err.errors) {\n                    err.errors.forEach((error, errIdx) => {\n                        this.log.error(`MQTT-Fehler #${errIdx + 1}: ${error}`);\n                    });\n                } else {\n                    this.log.error(`MQTT-Fehler: ${err.message}`);\n                }\n                if (this.isFirstTimeConnect) {\n                    this.stop &&\n                        (await this.stop({\n                            reason: \"MQTT connection seems invalid\",\n                            exitCode: EXIT_CODES.INVALID_ADAPTER_CONFIG,\n                        }));\n                }\n            });\n\n            // Hier k\u00F6nntest du auch weitere Event-Handler hinzuf\u00FCgen (z.B. f\u00FCr \"message\")\n        }\n    }\n\n    private async incrementComponentCounterState(comp: HomeassistantComponent): Promise<void> {\n        let compStateId: string;\n        switch (comp) {\n            case \"sensor\":\n                compStateId = \"sensor\";\n                break;\n            case \"switch\":\n                compStateId = \"switch\";\n                break;\n            case \"binary_sensor\":\n                compStateId = \"sensor\";\n                break;\n            default:\n                return;\n        }\n        compStateId = `${compStateId}_count`;\n        const cnt = ((await this.getStateAsync(compStateId))?.val as number) ?? 0;\n        await this.setStateChangedAsync(compStateId, cnt + 1, true);\n    }\n\n    private async mqttPublish(\n        topic: string,\n        payload: string | Buffer,\n        opts?: mqtt.IClientPublishOptions,\n    ): Promise<boolean> {\n        opts = { retain: false, ...opts };\n        return await new Promise(resolve => {\n            if (this.useMqttInstance && this.config.mqttInstance) {\n                this.sendTo(\n                    this.config.mqttInstance,\n                    \"sendMessage2Client\",\n                    { topic: topic, message: payload, ...opts },\n                    (response: any) => {\n                        if (response && response.error) {\n                            resolve(false);\n                        } else {\n                            resolve(true);\n                        }\n                    },\n                );\n            } else if (this.client) {\n                this.client.publish(topic, payload, opts, (err?: Error) => {\n                    if (err) {\n                        resolve(false);\n                    } else {\n                        resolve(true);\n                    }\n                });\n            } else {\n                this.log.error(\"Keine MQTT-Verbindung verf\u00FCgbar.\");\n                resolve(false);\n            }\n        });\n    }\n\n    /**\n     * F\u00FChrt einen kurzen Test-Publish aus, um zu pr\u00FCfen, ob das Schreiben m\u00F6glich ist.\n     */\n\n    private async checkDiscoveryWrite(): Promise<boolean> {\n        const testTopic = \"mqtt-discovery/write-test\";\n        const testMessage = \"true\";\n\n        return await this.mqttPublish(testTopic, testMessage, { retain: false });\n    }\n\n    /**\n     * Ver\u00F6ffentlicht eine MQTT Discovery Nachricht f\u00FCr ein Beispielger\u00E4t (Switch).\n     */\n    private async publishDiscovery(): Promise<void> {\n        await this.setState(\"device_count\", 0, true);\n        await this.setState(\"sensor_count\", 0, true);\n        await this.setState(\"switch_count\", 0, true);\n\n        const allStates = await findStatesMarkedWithEnum(this, \"homeassistant_enabled\");\n        if (allStates.length == 0) {\n            this.log.warn(\"No object with enum.function.homeassistant_enabled found\");\n            return;\n        }\n        await this.setState(\"device_count\", allStates.length, true);\n        for (const stateId of allStates) {\n            const state = await this.getForeignObjectAsync(stateId);\n            if (!state) {\n                continue;\n            }\n            const { haComponent, message: discovery } = generateDiscoveryMessage(stateId, state, this);\n            const success = await this.mqttPublish(discovery.topic, JSON.stringify(discovery.payload), {\n                retain: true,\n            });\n            if (!success) {\n                this.log.error(`Fehler beim Senden der Discovery-Nachricht`);\n            } else {\n                this.log.debug(`Discovery-Nachricht f\u00FCr \"${stateId}\" als \"${discovery.topic}\" gesendet.`);\n                await this.incrementComponentCounterState(haComponent);\n            }\n        }\n    }\n\n    /**\n     * Wird beim Herunterfahren des Adapters aufgerufen.\n     *\n     * @param callback - Callback, das signalisiert, dass der Adapter sauber heruntergefahren wurde.\n     */\n    private async onUnload(callback: () => void): Promise<void> {\n        try {\n            if (this.rescanInterval) {\n                clearInterval(this.rescanInterval);\n            }\n            if (this.client) {\n                this.client.end();\n            }\n\n            await this.setState(\"info.connection\", false, true);\n\n            callback();\n        } catch {\n            callback();\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new MqttDiscovery(options);\n} else {\n    // otherwise start the instance directly\n    (() => new MqttDiscovery())();\n}\n"],
  "mappings": "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",
  "names": []
}
