{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.5\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from \"@iobroker/adapter-core\";\nimport * as mqtt from \"mqtt\";\nimport { generateDiscoveryMessage } from \"./lib/mqtt-discovery-helper\";\nimport { findStatesMarkedWithEnum } from \"./lib/state-finder\";\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\nclass MqttDiscovery extends utils.Adapter {\n    // MQTT-Client speichern \u2013 initial null\n    private client: mqtt.MqttClient | null = null;\n    private useMqttInstance: boolean = false;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'mqtt-discovery',\n        });\n        // Registriere Event-Handler\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n    }\n\n\n    /**\n     * Wird aufgerufen, wenn der Adapter bereit ist.\n     */\n    private onReady(): void {\n        // Pr\u00FCfe, ob eine bestehende MQTT-Instanz ausgew\u00E4hlt wurde\n        if (this.config.mqttInstance && this.config.mqttInstance !== '') {\n            this.log.info(`Verwende vorhandene MQTT-Instanz: ${this.config.mqttInstance}`);\n            this.useMqttInstance = true;\n            // Bei Verwendung einer Instanz erfolgt das Publish sp\u00E4ter \u00FCber sendTo\n            this.checkDiscoveryWrite();\n        } else {\n            // Direktverbindung: Erstelle den Verbindungs-URL aus Protokoll, Host und Port\n            const protocol: string = this.config.mqttProtocol || 'mqtt';\n            const host: string = this.config.mqttHost || 'localhost';\n            const port: number = this.config.mqttPort || 1883;\n            const username: string = this.config.mqttUsername || '';\n            const password: string = this.config.mqttPassword || '';\n            const clientId: string = this.config.mqttClientId || 'ioBroker-mqtt-discovery';\n            const url = `${protocol}://${host}:${port}`;\n\n            this.log.info(`Verbinde direkt zu MQTT-Broker unter ${url} als ${clientId}`);\n            const options: mqtt.IClientOptions = { clientId };\n            if (username) options.username = username;\n            if (password) options.password = password;\n\n            this.client = mqtt.connect(url, options);\n            this.client.on('connect', () => {\n                this.log.info('Direkte MQTT-Verbindung hergestellt.');\n                this.publishDiscovery();\n                this.checkDiscoveryWrite();\n            });\n            this.client.on('error', (err: Error) => {\n                this.log.error(`MQTT-Fehler: ${err.message}`);\n            });\n            // Hier k\u00F6nntest du auch weitere Event-Handler hinzuf\u00FCgen (z.\u202FB. f\u00FCr \"message\")\n        }\n    }\n\n    /**\n     * F\u00FChrt einen kurzen Test-Publish aus, um zu pr\u00FCfen, ob das Schreiben m\u00F6glich ist.\n     */\n    private checkDiscoveryWrite(): void {\n        const testTopic = 'ioBroker/mqtt-discovery/test';\n        const testMessage = 'Test';\n        if (this.useMqttInstance && this.config.mqttInstance) {\n            this.sendTo(\n                this.config.mqttInstance,\n                'publish',\n                { topic: testTopic, message: testMessage, retain: false },\n                (response: any) => {\n                    if (response && response.error) {\n                        this.log.error(`Test-Publish via MQTT-Instanz fehlgeschlagen: ${response.error}`);\n                    } else {\n                        this.log.info('Test-Publish via MQTT-Instanz erfolgreich.');\n                    }\n                },\n            );\n        } else {\n            if (this.client) {\n                this.client.publish(testTopic, testMessage, { retain: false }, (err?: Error) => {\n                    if (err) {\n                        this.log.error(`Test-Publish fehlgeschlagen: ${err.message}`);\n                    } else {\n                        this.log.info('Test-Publish direkt erfolgreich.');\n                    }\n                });\n            }\n        }\n    }\n\n    /**\n     * Ver\u00F6ffentlicht eine MQTT Discovery Nachricht f\u00FCr ein Beispielger\u00E4t (Switch).\n     */\n    private async publishDiscovery(): Promise<void> {\n        if (!this.client) {\n            this.log.error('MQTT-Client ist nicht initialisiert.');\n            return;\n        }\n\n        const allStates = await findStatesMarkedWithEnum(this,'homeassistant_enabled');\n        if (allStates.length == 0) {\n            this.log.warn('No object with enum.function.homeassistant_enabled found');\n            return;\n        }\n\n        for (const stateId of allStates) {\n            const state = await this.getForeignObjectAsync(stateId);\n            if (!state) continue;\n            const discovery = generateDiscoveryMessage(stateId, state);\n            this.client.publish(discovery.topic, JSON.stringify(discovery.payload), { retain: true }, (err?: Error) => {\n                if (err) {\n                    this.log.error(`Fehler beim Senden der Discovery-Nachricht: ${err.message}`);\n                } else {\n                    this.log.info(`Discovery-Nachricht f\u00FCr \"${stateId}\" gesendet.`);\n                }\n            });\n        }\n\n        //\n        // const discoveryTopic = 'homeassistant/switch/my_device/config';\n        // const payload = {\n        //     name: 'My Device',\n        //     command_topic: 'iobroker/my_device/set', // Topic, an das HA Befehle sendet\n        //     state_topic: 'iobroker/my_device/state', // Topic, von dem HA den Status liest\n        //     unique_id: 'mqtt_discovery_my_device',\n        //     payload_on: 'ON',\n        //     payload_off: 'OFF',\n        // };\n        //\n        // // Publiziere die Discovery-Nachricht (retain: true sorgt daf\u00FCr, dass HA die Nachricht auch nach einem Neustart erh\u00E4lt)\n        // this.client.publish(discoveryTopic, JSON.stringify(payload), { retain: true }, (err?: Error) => {\n        //     if (err) {\n        //         this.log.error(`Fehler beim Senden der Discovery-Nachricht: ${err.message}`);\n        //     } else {\n        //         this.log.info('Discovery-Nachricht f\u00FCr \"My Device\" gesendet.');\n        //     }\n        // });\n    }\n\n    /**\n     * Handler f\u00FCr iobroker-State-\u00C4nderungen.\n     *\n     * @param id - Die ID des ge\u00E4nderten States (z.B. \"mqtt-discovery.0.my_device\")\n     * @param state - Der neue State oder null, falls der State gel\u00F6scht wurde.\n     */\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state) {\n            this.log.debug(`State ${id} ge\u00E4ndert: ${state.val}`);\n            if (this.client) {\n                // Beispielhaft: Konvertiere die State-ID in ein MQTT-Topic\n                // Ersetzt Punkte durch Slashes: \"mqtt-discovery.0.my_device\" -> \"iobroker/mqtt-discovery/0/my_device/state\"\n                const topic = `iobroker/${id.replace(/\\./g, '/')}/state`;\n                this.client.publish(topic, String(state.val), { retain: true }, (err?: Error) => {\n                    if (err) {\n                        this.log.error(`Fehler beim Senden des State ${id} an MQTT: ${err.message}`);\n                    } else {\n                        this.log.debug(`State ${id} erfolgreich an MQTT-Topic ${topic} gesendet.`);\n                    }\n                });\n            }\n        }\n    }\n\n    /**\n     * Wird beim Herunterfahren des Adapters aufgerufen.\n     *\n     * @param callback - Callback, das signalisiert, dass der Adapter sauber heruntergefahren wurde.\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            if (this.client) {\n                this.client.end();\n            }\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new MqttDiscovery(options);\n} else {\n    // otherwise start the instance directly\n    (() => new MqttDiscovery())();\n}\n"],
  "mappings": "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",
  "names": []
}
