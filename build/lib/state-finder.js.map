{
  "version": 3,
  "sources": ["../../src/lib/state-finder.ts"],
  "sourcesContent": ["/**\n *\n * @param adapter base adapter\n * @param enumId id of enum to use as marker - without the 'enum.functions.' prefix\n */\nexport async function findStatesMarkedWithEnum(adapter: ioBroker.Adapter, enumId: string): Promise<string[]> {\n    const resolveToStateIds = async (adapter: ioBroker.Adapter, objId: string): Promise<string[]> => {\n        const obj = await adapter.getForeignObjectAsync(objId);\n        if (!obj) {\n            return [];\n        }\n\n        switch (obj.type) {\n            case \"state\": //it's a final state - just return\n                return [obj._id];\n            case \"channel\":\n            case \"device\":\n            case \"folder\":\n            case \"meta\":\n            case \"adapter\":\n            case \"instance\":\n            case \"group\":\n                //just let through - this is handled below\n                break;\n            case \"enum\":\n            case \"host\":\n            case \"user\":\n            case \"script\":\n            case \"chart\":\n            case \"schedule\":\n            case \"config\":\n            case \"design\":\n                adapter.log.warn(`Found object of type '${obj.type}' which is not supported`);\n                return [];\n        }\n\n        //getting here means we have a kind of state container and can recurse\n\n        adapter.log.debug(`Found object '${obj._id}' of type '${obj.type}' - searching for members`);\n\n        const distinctList: string[] = [];\n        for (const stateId in await adapter.getForeignStatesAsync(`${obj._id}.*`)) {\n            if (!distinctList.includes(stateId)) {\n                distinctList.push(stateId);\n            }\n        }\n        return distinctList;\n    };\n\n    const enumObj = await adapter.getForeignObjectAsync(`enum.functions.${enumId}`);\n    let stateIds: string[] = [];\n    for (const member of enumObj?.common.members ?? []) {\n        stateIds = [...stateIds, ...(await resolveToStateIds(adapter, member))];\n    }\n    return stateIds;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA,eAAsB,yBAAyB,SAA2B,QAAmC;AAL7G;AAMI,QAAM,oBAAoB,OAAOA,UAA2B,UAAqC;AAC7F,UAAM,MAAM,MAAMA,SAAQ,sBAAsB,KAAK;AACrD,QAAI,CAAC,KAAK;AACN,aAAO,CAAC;AAAA,IACZ;AAEA,YAAQ,IAAI,MAAM;AAAA,MACd,KAAK;AACD,eAAO,CAAC,IAAI,GAAG;AAAA,MACnB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAED;AAAA,MACJ,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD,QAAAA,SAAQ,IAAI,KAAK,yBAAyB,IAAI,IAAI,0BAA0B;AAC5E,eAAO,CAAC;AAAA,IAChB;AAIA,IAAAA,SAAQ,IAAI,MAAM,iBAAiB,IAAI,GAAG,cAAc,IAAI,IAAI,2BAA2B;AAE3F,UAAM,eAAyB,CAAC;AAChC,eAAW,WAAW,MAAMA,SAAQ,sBAAsB,GAAG,IAAI,GAAG,IAAI,GAAG;AACvE,UAAI,CAAC,aAAa,SAAS,OAAO,GAAG;AACjC,qBAAa,KAAK,OAAO;AAAA,MAC7B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,QAAM,UAAU,MAAM,QAAQ,sBAAsB,kBAAkB,MAAM,EAAE;AAC9E,MAAI,WAAqB,CAAC;AAC1B,aAAW,WAAU,wCAAS,OAAO,YAAhB,YAA2B,CAAC,GAAG;AAChD,eAAW,CAAC,GAAG,UAAU,GAAI,MAAM,kBAAkB,SAAS,MAAM,CAAE;AAAA,EAC1E;AACA,SAAO;AACX;",
  "names": ["adapter"]
}
